# 3.4 事件总线与集群化

&emsp;&emsp;到目前为止，我们的介绍都是围绕着单个 *Verticle* ，但是一个项目通常不止一个模块，所以问题来了——

> 如果有多个 *Verticle*，它们之间怎么通信呢？

&emsp;&emsp;首先，我想定义一下“多个 *Verticle*”。我们这里说的“多个 *Verticle*”指的是我们实现的多个不同的 *Verticle* 类，区别于同一个 *Verticle* 类部署成多个实例——是的，这一点我前面没有讲，一个 *Verticle* 是单线程的，但是如果某个 *Verticle* 类对并发有更高的要求，想利用多核 CPU 的话，可以像这样部署：

```java
vertx.deployVerticle(MyHttpServerVerticle.class.getName(), 
    new DeploymentOptions().setInstances(8));
```
&emsp;&emsp;这段代码会为 `MyHttpServerVerticle` 部署 8 个实例，分别跑在 8 个线程上；我们不用担心它们监听同一个端口会有冲突， *Vert.x* 会为它们做分发处理。通常这种情况，这个实例数应当设置为 `Runtime.getRuntime().availableProcessors() * 2`（为什么？）。

&emsp;&emsp;上面插了一段单个 *Verticle* 利用多核 CPU 横向扩展的介绍，下面开始回答关于 “真 · 多个 *Verticle*” 的通信问题。  
&emsp;&emsp;*Vert.x* 模块间通信使用的是 *事件总线（EventBus）* 。在每一个 *Vert.x* 实例中，都存在一个唯一的 *事件总线（EventBus）* 实例，可以通过下面的方法获得：
```java
EventBus eb = vertx.eventBus();
```
&emsp;&emsp;作为 ***Vert.x* 的神经系统**，*事件总线* 允许应用的各个部分——无论这些部分是用哪种语言写的、是否在一个 *Vert.x* 实例中——都可以通过它进行通信。在通信的时候，消息会被发送到特定的 *地址（Address）*（一个自定义的字符串），由这个 *地址* 上注册的 *处理函数* 处理。一个 *地址* 上可以注册多个 *处理函数*。

&emsp;&emsp;*事件总线* 有以下两种通信方式：

1. *发布/订阅模式*
2. 点对点模式（支持 *请求/响应* 模式）

&emsp;&emsp;在 *发布/订阅模式* 中，*发布* 出去的消息会被发送到注册到目标 *地址* 上的每个 *处理函数* 中，类似于 *聊天群发*。在 *点对点模式* 中，消息会按照不严格的 *轮询算法* 发送到一个 *处理函数* 中，类似于“负载均衡”；在 *点对点模式* 中，如果需要消息接收方反馈处理结果，还可以在发送方法里添加一个 *处理函数*，实现类似于 *HTTP* 的 *请求/响应模式*。

&emsp;&emsp;在 *事件总线上* 可以传输任意类型的对象，通常如果是 *基本数据类型*、`String` 以及 *Vert.x* 提供的 `JsonObject`、`JsonArray`、`Buffer` 等对象，*事件总线* 可以直接传输；如果是某些自定义的类型，则需要先为这个类型实现一个用于序列化和反序列化的编解码器并注册到 *事件总线* 上。

&emsp;&emsp;*事件总线* 真正强大之处在于支持集群化。*Vert.x* 提供了集群模式，在执行一个 *Vert.x* 程序或模块时，可以通过添加 `-cluster` 参数开启集群模式。*事件总线* 可以通过这样一个 *Vert.x* 集群实现消息跨进程、跨节点传输。

&emsp;&emsp;基于这样一个集群化的 *事件总线*，*Vert.x* 提供了类似于 *Dubbo* 那样的远程过程调用模块，可以实现服务发现、管理、发布、订阅等分布式服务相关的功能。同时，官方还提供了一个 *JavaScript* 库，支持在 *Web* 前端页面直接与 *Vert.x* 后台的 *事件总线* 通信。