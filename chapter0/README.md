# 0. 开场白

&emsp;&emsp;各位同事大家好，今天我分享的内容题目是 *Vert.x 与异步无阻塞编程模型初探* 。

&emsp;&emsp;我刚入职那会儿曾经自学了一段时间 *Nodejs*，它适用于开发常见的 *IO密集型* 的 Web 应用，在处理高并发场景时性能有很优秀的性能。后来，我用 *Nodejs* 帮朋友做一个网站，在处理一些稍微有些复杂的逻辑时，十分不习惯 *Nodejs* 异步回调的编程方式，写了一些虽然能用但是可读性以及可维护性都非常差的代码，我甚至看不懂网上提供的解决办法，后来学习 *Nodejs* 这件事就不了了之了。

&emsp;&emsp;后来做交互中心统一消息推送的技术预研时，我们又发现了 *Vert.x* ，一个诞生于2011年最初命名为 *Node.x* 的“框架”（从这个名字大家大概能猜得出，它跟 *Nodejs* 有很多相似之处）。综合考虑性能、业务场景、开发运维成本等各方面因素的考虑，我们最终选择了它。于是，我又入了异步无阻塞编程模型的坑，进行了一些初步的探索，这也是我今天要跟大家分享的主要内容。

&emsp;&emsp;我主要从以下三个方面进行分享：
    
> * [什么是 *Vert.x* ?](../chapter1/README.md)
> * [为什么要用 *Vert.x* ?](../chapter2/README.md)
> * [怎么使用 *Vert.x* ?](../chapter3/README.md)

&emsp;&emsp;我觉得枯燥的名词定义和原理阐述并不能引起大家的兴趣，只有当我们真正去编码，去调试运行时，产生了疑惑，才会真正对那些高大上的名词和背后高效运行的原理感兴趣。所以，最后一条是我要讲的重点，可以让大家听完就可以直接用 *Vert.x* 进行开发；前面两条我只会简单带过，在最后留下一些[学习资料](../chapter4/README.md)，如果你对这些感兴趣，可以自行查阅。
